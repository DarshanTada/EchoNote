<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/echonote/RecordActivity/RecordModel.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/echonote/RecordActivity/RecordModel.java" />
              <option name="originalContent" value="package com.example.echonote.RecordActivity;&#10;&#10;import java.io.Serializable;&#10;&#10;public class RecordModel implements Serializable {&#10;    private String title;&#10;    private String filePath;&#10;    private long timestamp;&#10;&#10;    public RecordModel(String title, String filePath, long timestamp) {&#10;        this.title = title;&#10;        this.filePath = filePath;&#10;        this.timestamp = timestamp;&#10;    }&#10;&#10;    public String getTitle() { return title; }&#10;    public String getFilePath() { return filePath; }&#10;    public long getTimestamp() { return timestamp; }&#10;&#10;    @Override&#10;    public String toString() {&#10;        return &quot;Title: &quot; + title + &quot;\nFile: &quot; + filePath + &quot;\nTime: &quot; + timestamp;&#10;    }&#10;&#10;    @Override&#10;    public boolean equals(Object obj) {&#10;        if (this == obj) return true;&#10;        if (obj == null || getClass() != obj.getClass()) return false;&#10;        RecordModel that = (RecordModel) obj;&#10;        return timestamp == that.timestamp &amp;&amp;&#10;                (title != null ? title.equals(that.title) : that.title == null) &amp;&amp;&#10;                (filePath != null ? filePath.equals(that.filePath) : that.filePath == null);&#10;    }&#10;&#10;    @Override&#10;    public int hashCode() {&#10;        int result = title != null ? title.hashCode() : 0;&#10;        result = 31 * result + (filePath != null ? filePath.hashCode() : 0);&#10;        result = 31 * result + (int) (timestamp ^ (timestamp &gt;&gt;&gt; 32));&#10;        return result;&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.echonote.RecordActivity;&#10;&#10;import java.io.Serializable;&#10;&#10;public class RecordModel implements Serializable {&#10;    private String title;&#10;    private String filePath;&#10;    private long timestamp;&#10;&#10;    public RecordModel(String title, String filePath, long timestamp) {&#10;        this.title = title;&#10;        this.filePath = filePath;&#10;        this.timestamp = timestamp;&#10;    }&#10;&#10;    public String getTitle() { return title; }&#10;    public String getFilePath() { return filePath; }&#10;    public long getTimestamp() { return timestamp; }&#10;&#10;    public void setTitle(String title) {&#10;        this.title = title;&#10;    }&#10;&#10;    public void setFilePath(String filePath) {&#10;        this.filePath = filePath;&#10;    }&#10;&#10;    public void setTimestamp(long timestamp) {&#10;        this.timestamp = timestamp;&#10;    }&#10;&#10;    @Override&#10;    public String toString() {&#10;        return &quot;Title: &quot; + title + &quot;\nFile: &quot; + filePath + &quot;\nTime: &quot; + timestamp;&#10;    }&#10;&#10;    @Override&#10;    public boolean equals(Object obj) {&#10;        if (this == obj) return true;&#10;        if (obj == null || getClass() != obj.getClass()) return false;&#10;        RecordModel that = (RecordModel) obj;&#10;        return timestamp == that.timestamp &amp;&amp;&#10;                (title != null ? title.equals(that.title) : that.title == null) &amp;&amp;&#10;                (filePath != null ? filePath.equals(that.filePath) : that.filePath == null);&#10;    }&#10;&#10;    @Override&#10;    public int hashCode() {&#10;        int result = title != null ? title.hashCode() : 0;&#10;        result = 31 * result + (filePath != null ? filePath.hashCode() : 0);&#10;        result = 31 * result + (int) (timestamp ^ (timestamp &gt;&gt;&gt; 32));&#10;        return result;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/mobile/src/main/AndroidManifest.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/mobile/src/main/AndroidManifest.xml" />
              <option name="originalContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    package=&quot;com.example.echonote&quot;&gt;&#10;&#10;    &lt;application&#10;        android:allowBackup=&quot;true&quot;&#10;        android:icon=&quot;@mipmap/ic_launcher&quot;&#10;        android:label=&quot;@string/app_name&quot;&#10;        android:roundIcon=&quot;@mipmap/ic_launcher_round&quot;&#10;        android:supportsRtl=&quot;true&quot;&#10;        android:theme=&quot;@style/Theme.EchoNote&quot;&gt;&#10;&#10;        &lt;!-- Main launcher activity --&gt;&#10;        &lt;activity&#10;            android:name=&quot;.MainActivity_mobile&quot;&#10;            android:exported=&quot;true&quot;&gt;&#10;            &lt;intent-filter&gt;&#10;                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;&#10;                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;&#10;            &lt;/intent-filter&gt;&#10;        &lt;/activity&gt;&#10;&#10;        &lt;!-- MOM list activity --&gt;&#10;        &lt;activity&#10;            android:name=&quot;.MOMListActivity&quot;&#10;            android:exported=&quot;false&quot;&#10;            android:label=&quot;MOM List&quot; &gt;&#10;        &lt;/activity&gt;&#10;&#10;        &lt;!-- MOM detail activity --&gt;&#10;        &lt;activity&#10;            android:name=&quot;.MOMDetailActivity&quot;&#10;            android:exported=&quot;false&quot;&#10;            android:label=&quot;MOM Details&quot; &gt;&#10;        &lt;/activity&gt;&#10;&#10;        &lt;!-- Recording list activity --&gt;&#10;        &lt;activity&#10;            android:name=&quot;.RecordingListActivity&quot;&#10;            android:exported=&quot;false&quot;&#10;            android:label=&quot;Recording List&quot; /&gt;&#10;&#10;        &lt;!-- Service to listen for recordings --&gt;&#10;        &lt;service&#10;            android:name=&quot;.RecordingListenerService&quot;&#10;            android:exported=&quot;true&quot;&gt;&#10;            &lt;intent-filter&gt;&#10;                &lt;action android:name=&quot;com.google.android.gms.wearable.BIND_LISTENER&quot; /&gt;&#10;            &lt;/intent-filter&gt;&#10;        &lt;/service&gt;&#10;&#10;        &lt;service&#10;            android:name=&quot;.RecordingChannelService&quot;&#10;            android:exported=&quot;true&quot;&gt;&#10;            &lt;intent-filter&gt;&#10;                &lt;action android:name=&quot;com.google.android.gms.wearable.BIND_LISTENER&quot; /&gt;&#10;            &lt;/intent-filter&gt;&#10;        &lt;/service&gt;&#10;&#10;        &lt;service android:name=&quot;.WearDataListenerService&quot; android:exported=&quot;true&quot;&gt;&#10;            &lt;intent-filter&gt;&#10;                &lt;action android:name=&quot;com.google.android.gms.wearable.BIND_LISTENER&quot; /&gt;&#10;            &lt;/intent-filter&gt;&#10;        &lt;/service&gt;&#10;&#10;    &lt;/application&gt;&#10;&#10;    &lt;!-- Permissions for reading/writing audio files in external storage --&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.READ_MEDIA_AUDIO&quot;/&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.READ_MEDIA_IMAGES&quot;/&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.READ_MEDIA_VIDEO&quot;/&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot;/&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;/&gt;&#10;&#10;&#10;&lt;/manifest&gt;&#10;" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    package=&quot;com.example.echonote&quot;&gt;&#10;&#10;    &lt;application&#10;        android:allowBackup=&quot;true&quot;&#10;        android:icon=&quot;@mipmap/ic_launcher&quot;&#10;        android:label=&quot;@string/app_name&quot;&#10;        android:roundIcon=&quot;@mipmap/ic_launcher_round&quot;&#10;        android:supportsRtl=&quot;true&quot;&#10;        android:theme=&quot;@style/Theme.EchoNote&quot;&gt;&#10;&#10;        &lt;!-- Main launcher activity --&gt;&#10;        &lt;activity&#10;            android:name=&quot;.MainActivity_mobile&quot;&#10;            android:exported=&quot;true&quot;&gt;&#10;            &lt;intent-filter&gt;&#10;                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;&#10;                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;&#10;            &lt;/intent-filter&gt;&#10;        &lt;/activity&gt;&#10;&#10;        &lt;!-- MOM list activity --&gt;&#10;        &lt;activity&#10;            android:name=&quot;.MOMListActivity&quot;&#10;            android:exported=&quot;false&quot;&#10;            android:label=&quot;MOM List&quot; &gt;&#10;        &lt;/activity&gt;&#10;&#10;        &lt;!-- MOM detail activity --&gt;&#10;        &lt;activity&#10;            android:name=&quot;.MOMDetailActivity&quot;&#10;            android:exported=&quot;false&quot;&#10;            android:label=&quot;MOM Details&quot; &gt;&#10;        &lt;/activity&gt;&#10;&#10;        &lt;!-- Recording list activity --&gt;&#10;        &lt;activity&#10;            android:name=&quot;.RecordingListActivity&quot;&#10;            android:exported=&quot;false&quot;&#10;            android:label=&quot;Recording List&quot; /&gt;&#10;&#10;        &lt;!-- Video player activity --&gt;&#10;        &lt;activity&#10;            android:name=&quot;.VideoPlayerActivity&quot;&#10;            android:exported=&quot;false&quot;&#10;            android:label=&quot;Video Player&quot; /&gt;&#10;&#10;        &lt;!-- Service to listen for recordings --&gt;&#10;        &lt;service&#10;            android:name=&quot;.RecordingListenerService&quot;&#10;            android:exported=&quot;true&quot;&gt;&#10;            &lt;intent-filter&gt;&#10;                &lt;action android:name=&quot;com.google.android.gms.wearable.BIND_LISTENER&quot; /&gt;&#10;            &lt;/intent-filter&gt;&#10;        &lt;/service&gt;&#10;&#10;        &lt;service&#10;            android:name=&quot;.RecordingChannelService&quot;&#10;            android:exported=&quot;true&quot;&gt;&#10;            &lt;intent-filter&gt;&#10;                &lt;action android:name=&quot;com.google.android.gms.wearable.BIND_LISTENER&quot; /&gt;&#10;            &lt;/intent-filter&gt;&#10;        &lt;/service&gt;&#10;&#10;        &lt;service android:name=&quot;.WearDataListenerService&quot; android:exported=&quot;true&quot;&gt;&#10;            &lt;intent-filter&gt;&#10;                &lt;action android:name=&quot;com.google.android.gms.wearable.BIND_LISTENER&quot; /&gt;&#10;            &lt;/intent-filter&gt;&#10;        &lt;/service&gt;&#10;&#10;        &lt;!-- FileProvider for sharing files --&gt;&#10;        &lt;provider&#10;            android:name=&quot;androidx.core.content.FileProvider&quot;&#10;            android:authorities=&quot;com.example.echonote.fileprovider&quot;&#10;            android:exported=&quot;false&quot;&#10;            android:grantUriPermissions=&quot;true&quot;&gt;&#10;            &lt;meta-data&#10;                android:name=&quot;android.support.FILE_PROVIDER_PATHS&quot;&#10;                android:resource=&quot;@xml/file_paths&quot; /&gt;&#10;        &lt;/provider&gt;&#10;&#10;    &lt;/application&gt;&#10;&#10;    &lt;!-- Permissions for reading/writing audio files in external storage --&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.READ_MEDIA_AUDIO&quot;/&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.READ_MEDIA_IMAGES&quot;/&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.READ_MEDIA_VIDEO&quot;/&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot;/&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;/&gt;&#10;&#10;&#10;&lt;/manifest&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/mobile/src/main/java/com/example/echonote/RecordingChannelService.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/mobile/src/main/java/com/example/echonote/RecordingChannelService.java" />
              <option name="originalContent" value="// package: com.example.mobile&#10;package com.example.echonote; // or your shared package name&#10;&#10;import android.util.Log;&#10;&#10;import com.example.shared.RecordModel;&#10;import com.example.shared.RecordStorageHelper;&#10;import com.google.android.gms.wearable.Channel;&#10;import com.google.android.gms.wearable.ChannelClient;&#10;import com.google.android.gms.wearable.Wearable;&#10;import com.google.android.gms.wearable.WearableListenerService;&#10;&#10;import java.io.File;&#10;import java.io.FileOutputStream;&#10;import java.io.InputStream;&#10;import com.google.android.gms.wearable.ChannelClient;&#10;import com.google.android.gms.wearable.Wearable;&#10;import com.google.android.gms.wearable.WearableListenerService;&#10;&#10;public class RecordingChannelService extends WearableListenerService {&#10;&#10;    private static final String TAG = &quot;RecordingChannelSvc&quot;;&#10;    private static final String CHANNEL_PATH = &quot;/recording_channel&quot;;&#10;&#10;    @Override&#10;    public void onChannelOpened(ChannelClient.Channel channel) {&#10;        Log.d(TAG, &quot;onChannelOpened: path=&quot; + channel.getPath() + &quot; node=&quot; + channel.getNodeId());&#10;        if (!CHANNEL_PATH.equals(channel.getPath())) {&#10;            Log.d(TAG, &quot;Ignoring channel with different path: &quot; + channel.getPath());&#10;            return;&#10;        }&#10;&#10;        Wearable.getChannelClient(this)&#10;                .getInputStream(channel)&#10;                .addOnSuccessListener(inputStream -&gt; {&#10;                    // 'inputStream' is already the stream you read from&#10;                    File dir = getExternalFilesDir(null);&#10;                    File folder = new File(dir, &quot;EchoNoteAudio&quot;);&#10;                    if (!folder.exists()) folder.mkdirs();&#10;&#10;                    File outFile = new File(folder, &quot;received_&quot; + System.currentTimeMillis() + &quot;.txt&quot;); // For testing, save as .txt&#10;                    Log.d(TAG, &quot;Saving incoming stream to: &quot; + outFile.getAbsolutePath());&#10;&#10;                    new Thread(() -&gt; {&#10;                        long startTime = System.currentTimeMillis();&#10;                        long totalBytes = 0;&#10;                        try (FileOutputStream fos = new FileOutputStream(outFile)) {&#10;                            byte[] buffer = new byte[65536]; // Increased buffer size&#10;                            int read;&#10;                            Log.d(TAG, &quot;Begin reading from inputStream...&quot;);&#10;                            while ((read = inputStream.read(buffer)) != -1) {&#10;                                fos.write(buffer, 0, read);&#10;                                totalBytes += read;&#10;                            }&#10;                            fos.flush();&#10;                            long endTime = System.currentTimeMillis();&#10;                            Log.d(TAG, &quot;Finished reading inputStream. Total bytes: &quot; + totalBytes + &quot;, Time: &quot; + (endTime - startTime) + &quot; ms&quot;);&#10;&#10;                            Log.d(TAG, &quot;Saving received file at: &quot; + outFile.getAbsolutePath());&#10;                            RecordModel record = new RecordModel(outFile.getName(), outFile.getAbsolutePath(), System.currentTimeMillis());&#10;                            RecordStorageHelper.saveRecord(this, record);&#10;                            Log.d(TAG, &quot;Called saveRecord. records.dat should now exist at: &quot; + new java.io.File(getExternalFilesDir(null), &quot;EchoNoteAudio/records.dat&quot;).getAbsolutePath());&#10;&#10;                            int count = RecordStorageHelper.loadRecords(this).size();&#10;                            Log.d(TAG, &quot;Saved file and record. Total saved records: &quot; + count);&#10;&#10;                        } catch (Exception e) {&#10;                            Log.e(TAG, &quot;Error writing incoming channel to file&quot;, e);&#10;                        } finally {&#10;                            try {&#10;                                inputStream.close();&#10;                                Wearable.getChannelClient(this).close(channel);&#10;                            } catch (Exception ignored) {}&#10;                        }&#10;                    }).start();&#10;                })&#10;                .addOnFailureListener(e -&gt; Log.e(TAG, &quot;Failed to get input stream for channel&quot;, e));&#10;    }&#10;&#10;&#10;    @Override&#10;    public void onChannelClosed(ChannelClient.Channel channel, int closeReason, int appSpecificErrorCode) {&#10;        Log.d(TAG, &quot;onChannelClosed: &quot; + channel.getPath() + &quot; reason=&quot; + closeReason);&#10;        super.onChannelClosed(channel, closeReason, appSpecificErrorCode);&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="// package: com.example.mobile&#10;package com.example.echonote; // or your shared package name&#10;&#10;import android.util.Log;&#10;&#10;import com.example.shared.RecordModel;&#10;import com.example.shared.RecordStorageHelper;&#10;import com.google.android.gms.wearable.Channel;&#10;import com.google.android.gms.wearable.ChannelClient;&#10;import com.google.android.gms.wearable.Wearable;&#10;import com.google.android.gms.wearable.WearableListenerService;&#10;&#10;import java.io.File;&#10;import java.io.FileOutputStream;&#10;import java.io.InputStream;&#10;import com.google.android.gms.wearable.ChannelClient;&#10;import com.google.android.gms.wearable.Wearable;&#10;import com.google.android.gms.wearable.WearableListenerService;&#10;&#10;public class RecordingChannelService extends WearableListenerService {&#10;&#10;    private static final String TAG = &quot;RecordingChannelSvc&quot;;&#10;    private static final String CHANNEL_PATH = &quot;/recording_channel&quot;;&#10;&#10;    @Override&#10;    public void onChannelOpened(ChannelClient.Channel channel) {&#10;        Log.d(TAG, &quot;onChannelOpened: path=&quot; + channel.getPath() + &quot; node=&quot; + channel.getNodeId());&#10;        if (!CHANNEL_PATH.equals(channel.getPath())) {&#10;            Log.d(TAG, &quot;Ignoring channel with different path: &quot; + channel.getPath());&#10;            return;&#10;        }&#10;&#10;        Wearable.getChannelClient(this)&#10;                .getInputStream(channel)&#10;                .addOnSuccessListener(inputStream -&gt; {&#10;                    // 'inputStream' is already the stream you read from&#10;                    File dir = getExternalFilesDir(null);&#10;                    File folder = new File(dir, &quot;EchoNoteAudio&quot;);&#10;                    if (!folder.exists()) folder.mkdirs();&#10;&#10;                    File outFile = new File(folder, &quot;received_&quot; + System.currentTimeMillis() + &quot;.txt&quot;); // For testing, save as .txt&#10;                    Log.d(TAG, &quot;Saving incoming stream to: &quot; + outFile.getAbsolutePath());&#10;&#10;                    new Thread(() -&gt; {&#10;                        long startTime = System.currentTimeMillis();&#10;                        long totalBytes = 0;&#10;                        try (FileOutputStream fos = new FileOutputStream(outFile)) {&#10;                            byte[] buffer = new byte[65536];&#10;                            int read;&#10;                            Log.d(TAG, &quot;Begin reading from inputStream...&quot;);&#10;                            while ((read = inputStream.read(buffer)) != -1) {&#10;                                fos.write(buffer, 0, read);&#10;                                totalBytes += read;&#10;                            }&#10;                            fos.flush();&#10;                            long endTime = System.currentTimeMillis();&#10;                            Log.d(TAG, &quot;Finished reading inputStream. Total bytes: &quot; + totalBytes + &quot;, Time: &quot; + (endTime - startTime) + &quot; ms&quot;);&#10;&#10;                            // Only create a new RecordModel with the mobile's local file path&#10;                            RecordModel record = new RecordModel(outFile.getName(), outFile.getAbsolutePath(), System.currentTimeMillis());&#10;                            RecordStorageHelper.saveRecord(this, record);&#10;                            Log.d(TAG, &quot;Saved new record to records.dat: &quot; + outFile.getAbsolutePath());&#10;&#10;                            int count = RecordStorageHelper.loadRecords(this).size();&#10;                            Log.d(TAG, &quot;Saved file and record. Total saved records: &quot; + count);&#10;&#10;                        } catch (Exception e) {&#10;                            Log.e(TAG, &quot;Error writing incoming channel to file&quot;, e);&#10;                        } finally {&#10;                            try {&#10;                                inputStream.close();&#10;                                Wearable.getChannelClient(this).close(channel);&#10;                            } catch (Exception ignored) {}&#10;                        }&#10;                    }).start();&#10;                })&#10;                .addOnFailureListener(e -&gt; Log.e(TAG, &quot;Failed to get input stream for channel&quot;, e));&#10;    }&#10;&#10;&#10;    @Override&#10;    public void onChannelClosed(ChannelClient.Channel channel, int closeReason, int appSpecificErrorCode) {&#10;        Log.d(TAG, &quot;onChannelClosed: &quot; + channel.getPath() + &quot; reason=&quot; + closeReason);&#10;        super.onChannelClosed(channel, closeReason, appSpecificErrorCode);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/mobile/src/main/java/com/example/echonote/RecordingListActivity.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/mobile/src/main/java/com/example/echonote/RecordingListActivity.java" />
              <option name="originalContent" value="package com.example.echonote;&#10;&#10;import android.app.Activity;&#10;import android.content.BroadcastReceiver;&#10;import android.content.Context;&#10;import android.content.Intent;&#10;import android.content.IntentFilter;&#10;import android.os.Bundle;&#10;import android.util.Log;&#10;import android.view.View;&#10;import android.widget.AdapterView;&#10;import android.widget.ArrayAdapter;&#10;import android.widget.ListView;&#10;import android.widget.Toast;&#10;&#10;import androidx.localbroadcastmanager.content.LocalBroadcastManager;&#10;&#10;import com.example.echonote.databinding.ActivityRecordingListBinding;&#10;import com.example.shared.RecordModel;&#10;&#10;import java.io.File;&#10;import java.util.ArrayList;&#10;&#10;public class RecordingListActivity extends Activity {&#10;    private ListView listView;&#10;    private ArrayAdapter&lt;RecordModel&gt; adapter;&#10;    private ArrayList&lt;RecordModel&gt; recordList;&#10;&#10;    private BroadcastReceiver newRecordingReceiver = new BroadcastReceiver() {&#10;        @Override&#10;        public void onReceive(Context context, Intent intent) {&#10;            Log.d(&quot;RecordingListActivity&quot;, &quot;New recording received broadcast&quot;);&#10;            reloadRecordings();&#10;        }&#10;    };&#10;&#10;    @Override&#10;    protected void onCreate(Bundle savedInstanceState) {&#10;        super.onCreate(savedInstanceState);&#10;        ActivityRecordingListBinding binding = ActivityRecordingListBinding.inflate(getLayoutInflater());&#10;        setContentView(binding.getRoot());&#10;        listView = binding.recordingListView;&#10;        recordList = new ArrayList&lt;&gt;();&#10;&#10;        setupAdapter();&#10;        reloadRecordings();&#10;&#10;        listView.setOnItemClickListener((parent, view, position, id) -&gt; {&#10;            RecordModel record = recordList.get(position);&#10;            Intent intent = new Intent(RecordingListActivity.this, RecordingDetailActivity.class);&#10;            intent.putExtra(&quot;title&quot;, record.getTitle());&#10;            intent.putExtra(&quot;filePath&quot;, record.getFilePath());&#10;            intent.putExtra(&quot;timestamp&quot;, record.getTimestamp());&#10;            startActivity(intent);&#10;        });&#10;&#10;        LocalBroadcastManager.getInstance(this).registerReceiver(&#10;                newRecordingReceiver, new IntentFilter(&quot;com.example.echonote.NEW_RECORDING_RECEIVED&quot;));&#10;    }&#10;&#10;    private void setupAdapter() {&#10;        adapter = new ArrayAdapter&lt;RecordModel&gt;(this, android.R.layout.simple_list_item_1, recordList) {&#10;            @Override&#10;            public View getView(int position, View convertView, android.view.ViewGroup parent) {&#10;                View view = super.getView(position, convertView, parent);&#10;                RecordModel record = getItem(position);&#10;                if (record != null) {&#10;                    ((android.widget.TextView) view).setText(record.getTitle());&#10;                }&#10;                return view;&#10;            }&#10;        };&#10;        listView.setAdapter(adapter);&#10;    }&#10;&#10;    private void reloadRecordings() {&#10;        recordList.clear();&#10;        File dir = getExternalFilesDir(null);&#10;        File folder = new File(dir, &quot;EchoNoteAudio&quot;);&#10;        Log.d(&quot;RecordingListActivity&quot;, &quot;Looking for mp4 files in: &quot; + folder.getAbsolutePath());&#10;        if (folder.exists()) {&#10;            File[] files = folder.listFiles((d, name) -&gt; name.toLowerCase().endsWith(&quot;.mp4&quot;));&#10;            Log.d(&quot;RecordingListActivity&quot;, &quot;Found files: &quot; + (files == null ? 0 : files.length));&#10;            if (files != null) {&#10;                for (File f : files) {&#10;                    Log.d(&quot;RecordingListActivity&quot;, &quot;Found mp4: &quot; + f.getAbsolutePath());&#10;                    recordList.add(new RecordModel(f.getName(), f.getAbsolutePath(), f.lastModified()));&#10;                }&#10;            }&#10;        } else {&#10;            Log.w(&quot;RecordingListActivity&quot;, &quot;EchoNoteAudio folder does not exist!&quot;);&#10;            Toast.makeText(this, &quot;No mp4 files found in EchoNoteAudio folder&quot;, Toast.LENGTH_LONG).show();&#10;        }&#10;        if (recordList.isEmpty()) {&#10;            Toast.makeText(this, &quot;No mp4 files found in EchoNoteAudio folder&quot;, Toast.LENGTH_LONG).show();&#10;        }&#10;        adapter.notifyDataSetChanged();&#10;    }&#10;&#10;    @Override&#10;    protected void onDestroy() {&#10;        super.onDestroy();&#10;        LocalBroadcastManager.getInstance(this).unregisterReceiver(newRecordingReceiver);&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.echonote;&#10;&#10;import android.app.Activity;&#10;import android.content.BroadcastReceiver;&#10;import android.content.Context;&#10;import android.content.Intent;&#10;import android.content.IntentFilter;&#10;import android.os.Bundle;&#10;import android.util.Log;&#10;import android.view.View;&#10;import android.widget.AdapterView;&#10;import android.widget.ArrayAdapter;&#10;import android.widget.ListView;&#10;import android.widget.Toast;&#10;&#10;import androidx.localbroadcastmanager.content.LocalBroadcastManager;&#10;&#10;import com.example.echonote.databinding.ActivityRecordingListBinding;&#10;import com.example.shared.RecordModel;&#10;&#10;import java.io.File;&#10;import java.util.ArrayList;&#10;&#10;public class RecordingListActivity extends Activity {&#10;    private ListView listView;&#10;    private ArrayAdapter&lt;RecordModel&gt; adapter;&#10;    private ArrayList&lt;RecordModel&gt; recordList;&#10;&#10;    private BroadcastReceiver newRecordingReceiver = new BroadcastReceiver() {&#10;        @Override&#10;        public void onReceive(Context context, Intent intent) {&#10;            Log.d(&quot;RecordingListActivity&quot;, &quot;New recording received broadcast&quot;);&#10;            reloadRecordings();&#10;        }&#10;    };&#10;&#10;    @Override&#10;    protected void onCreate(Bundle savedInstanceState) {&#10;        super.onCreate(savedInstanceState);&#10;        ActivityRecordingListBinding binding = ActivityRecordingListBinding.inflate(getLayoutInflater());&#10;        setContentView(binding.getRoot());&#10;        listView = binding.recordingListView;&#10;        recordList = new ArrayList&lt;&gt;();&#10;&#10;        setupAdapter();&#10;        reloadRecordings();&#10;&#10;        listView.setOnItemClickListener((parent, view, position, id) -&gt; {&#10;            RecordModel record = recordList.get(position);&#10;            Intent intent = new Intent(RecordingListActivity.this, VideoPlayerActivity.class);&#10;            intent.putExtra(&quot;mp4_path&quot;, record.getFilePath());&#10;            startActivity(intent);&#10;        });&#10;&#10;        LocalBroadcastManager.getInstance(this).registerReceiver(&#10;                newRecordingReceiver, new IntentFilter(&quot;com.example.echonote.NEW_RECORDING_RECEIVED&quot;));&#10;    }&#10;&#10;    private void setupAdapter() {&#10;        adapter = new ArrayAdapter&lt;RecordModel&gt;(this, android.R.layout.simple_list_item_1, recordList) {&#10;            @Override&#10;            public View getView(int position, View convertView, android.view.ViewGroup parent) {&#10;                View view = super.getView(position, convertView, parent);&#10;                RecordModel record = getItem(position);&#10;                if (record != null) {&#10;                    ((android.widget.TextView) view).setText(record.getTitle());&#10;                }&#10;                return view;&#10;            }&#10;        };&#10;        listView.setAdapter(adapter);&#10;    }&#10;&#10;    private void reloadRecordings() {&#10;        recordList.clear();&#10;        File dir = getExternalFilesDir(null);&#10;        File folder = new File(dir, &quot;EchoNoteAudio&quot;);&#10;        Log.d(&quot;RecordingListActivity&quot;, &quot;Looking for mp4 files in: &quot; + folder.getAbsolutePath());&#10;        if (folder.exists()) {&#10;            File[] files = folder.listFiles((d, name) -&gt; name.toLowerCase().endsWith(&quot;.mp4&quot;));&#10;            Log.d(&quot;RecordingListActivity&quot;, &quot;Found files: &quot; + (files == null ? 0 : files.length));&#10;            if (files != null) {&#10;                for (File f : files) {&#10;                    Log.d(&quot;RecordingListActivity&quot;, &quot;Found mp4: &quot; + f.getAbsolutePath());&#10;                    recordList.add(new RecordModel(f.getName(), f.getAbsolutePath(), f.lastModified()));&#10;                }&#10;            }&#10;        } else {&#10;            Log.w(&quot;RecordingListActivity&quot;, &quot;EchoNoteAudio folder does not exist!&quot;);&#10;            Toast.makeText(this, &quot;No mp4 files found in EchoNoteAudio folder&quot;, Toast.LENGTH_LONG).show();&#10;        }&#10;        if (recordList.isEmpty()) {&#10;            Toast.makeText(this, &quot;No mp4 files found in EchoNoteAudio folder&quot;, Toast.LENGTH_LONG).show();&#10;        }&#10;        adapter.notifyDataSetChanged();&#10;    }&#10;&#10;    @Override&#10;    protected void onDestroy() {&#10;        super.onDestroy();&#10;        LocalBroadcastManager.getInstance(this).unregisterReceiver(newRecordingReceiver);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/mobile/src/main/java/com/example/echonote/RecordingListenerService.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/mobile/src/main/java/com/example/echonote/RecordingListenerService.java" />
              <option name="originalContent" value="package com.example.echonote;&#10;&#10;import android.util.Log;&#10;&#10;import com.example.shared.RecordModel;&#10;import com.example.shared.RecordStorageHelper;&#10;import com.google.android.gms.wearable.Asset;&#10;import com.google.android.gms.wearable.DataEvent;&#10;import com.google.android.gms.wearable.DataEventBuffer;&#10;import com.google.android.gms.wearable.DataMap;&#10;import com.google.android.gms.wearable.DataMapItem;&#10;import com.google.android.gms.wearable.Wearable;&#10;import com.google.android.gms.wearable.WearableListenerService;&#10;&#10;import java.io.File;&#10;import java.io.FileOutputStream;&#10;import java.io.InputStream;&#10;&#10;public class RecordingListenerService extends WearableListenerService {&#10;&#10;    private static final String TAG = &quot;RecordingListenerService&quot;;&#10;    private static final String RECORDING_PATH = &quot;/recording_data&quot;;&#10;    private static final String MP4_PATH = &quot;/mp4_file&quot;;&#10;&#10;    @Override&#10;    public void onDataChanged(DataEventBuffer dataEvents) {&#10;        try {&#10;            for (DataEvent event : dataEvents) {&#10;                if (event.getType() == DataEvent.TYPE_CHANGED) {&#10;                    String path = event.getDataItem().getUri().getPath();&#10;                    Log.d(TAG, &quot;onDataChanged: path=&quot; + path);&#10;&#10;                    if (RECORDING_PATH.equals(path)) {&#10;                        DataMap dataMap = DataMapItem.fromDataItem(event.getDataItem()).getDataMap();&#10;                        final String title = dataMap.getString(&quot;title&quot;);&#10;                        final String fileName = dataMap.getString(&quot;fileName&quot;);&#10;                        final long timestamp = dataMap.getLong(&quot;timestamp&quot;);&#10;                        final Asset audioAsset = dataMap.getAsset(&quot;audio&quot;);&#10;&#10;                        if (audioAsset == null) {&#10;                            Log.e(TAG, &quot;No audio asset found in DataMap&quot;);&#10;                            continue;&#10;                        }&#10;&#10;                        // Latest API: getFdForAsset returns ParcelFileDescriptor&#10;                        Wearable.getDataClient(this).getFdForAsset(audioAsset)&#10;                                .addOnSuccessListener(parcelFileDescriptor -&gt; {&#10;                                    if (parcelFileDescriptor == null) {&#10;                                        Log.e(TAG, &quot;ParcelFileDescriptor is null&quot;);&#10;                                        return;&#10;                                    }&#10;&#10;                                    File dir = getExternalFilesDir(null);&#10;                                    File folder = new File(dir, &quot;EchoNoteAudio&quot;);&#10;                                    if (!folder.exists()) {&#10;                                        folder.mkdirs();&#10;                                    }&#10;                                    File outFile = new File(folder, fileName);&#10;&#10;                                    Log.d(TAG, &quot;Saving audio asset to: &quot; + outFile.getAbsolutePath());&#10;&#10;                                    try (&#10;                                            InputStream assetInputStream = parcelFileDescriptor.getInputStream();&#10;                                            FileOutputStream fos = new FileOutputStream(outFile)&#10;                                    ) {&#10;                                        byte[] buffer = new byte[8192];&#10;                                        int read;&#10;                                        while ((read = assetInputStream.read(buffer)) != -1) {&#10;                                            fos.write(buffer, 0, read);&#10;                                        }&#10;                                        fos.flush();&#10;&#10;                                        Log.d(TAG, &quot;Audio file saved: &quot; + outFile.getAbsolutePath());&#10;&#10;                                        // Do not try to get data from path, just save the file&#10;&#10;                                    } catch (Exception e) {&#10;                                        Log.e(TAG, &quot;Failed to write asset to file&quot;, e);&#10;                                    }&#10;                                })&#10;                                .addOnFailureListener(e -&gt;&#10;                                        Log.e(TAG, &quot;Failed to get asset ParcelFileDescriptor&quot;, e));&#10;                    } else if (MP4_PATH.equals(path)) {&#10;                        DataMap dataMap = DataMapItem.fromDataItem(event.getDataItem()).getDataMap();&#10;                        final String fileName = dataMap.getString(&quot;file_name&quot;);&#10;                        final long timestamp = dataMap.getLong(&quot;timestamp&quot;);&#10;                        final Asset mp4Asset = dataMap.getAsset(&quot;mp4_asset&quot;);&#10;&#10;                        if (mp4Asset == null) {&#10;                            Log.e(TAG, &quot;No mp4 asset found in DataMap&quot;);&#10;                            continue;&#10;                        }&#10;&#10;                        Wearable.getDataClient(this).getFdForAsset(mp4Asset)&#10;                                .addOnSuccessListener(parcelFileDescriptor -&gt; {&#10;                                    if (parcelFileDescriptor == null) {&#10;                                        Log.e(TAG, &quot;ParcelFileDescriptor is null&quot;);&#10;                                        return;&#10;                                    }&#10;                                    File dir = getExternalFilesDir(null);&#10;                                    File folder = new File(dir, &quot;EchoNoteAudio&quot;);&#10;                                    if (!folder.exists()) {&#10;                                        folder.mkdirs();&#10;                                    }&#10;                                    File outFile = new File(folder, fileName);&#10;                                    Log.d(TAG, &quot;Saving mp4 asset to: &quot; + outFile.getAbsolutePath());&#10;                                    try (&#10;                                            InputStream assetInputStream = parcelFileDescriptor.getInputStream();&#10;                                            FileOutputStream fos = new FileOutputStream(outFile)&#10;                                    ) {&#10;                                        byte[] buffer = new byte[8192];&#10;                                        int read;&#10;                                        while ((read = assetInputStream.read(buffer)) != -1) {&#10;                                            fos.write(buffer, 0, read);&#10;                                        }&#10;                                        fos.flush();&#10;                                        Log.d(TAG, &quot;MP4 file saved: &quot; + outFile.getAbsolutePath());&#10;                                        // Save RecordModel for this mp4 file so it appears in the list&#10;                                        RecordModel recordModel = new RecordModel(fileName, outFile.getAbsolutePath(), timestamp);&#10;                                        RecordStorageHelper.saveRecord(RecordingListenerService.this, recordModel);&#10;                                        int count = RecordStorageHelper.loadRecords(RecordingListenerService.this).size();&#10;                                        Log.d(TAG, &quot;MP4 RecordModel saved. Total records: &quot; + count);&#10;                                    } catch (Exception e) {&#10;                                        Log.e(TAG, &quot;Failed to write mp4 asset to file&quot;, e);&#10;                                    }&#10;                                })&#10;                                .addOnFailureListener(e -&gt;&#10;                                        Log.e(TAG, &quot;Failed to get mp4 asset ParcelFileDescriptor&quot;, e));&#10;                    }&#10;                } else if (event.getType() == DataEvent.TYPE_DELETED) {&#10;                    Log.d(TAG, &quot;DataItem deleted: &quot; + event.getDataItem().getUri());&#10;                }&#10;            }&#10;        } catch (Exception e) {&#10;            Log.e(TAG, &quot;onDataChanged failed&quot;, e);&#10;        } finally {&#10;            dataEvents.release();&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.echonote;&#10;&#10;import android.util.Log;&#10;&#10;import com.example.shared.RecordModel;&#10;import com.example.shared.RecordStorageHelper;&#10;import com.google.android.gms.wearable.Asset;&#10;import com.google.android.gms.wearable.DataEvent;&#10;import com.google.android.gms.wearable.DataEventBuffer;&#10;import com.google.android.gms.wearable.DataMap;&#10;import com.google.android.gms.wearable.DataMapItem;&#10;import com.google.android.gms.wearable.Wearable;&#10;import com.google.android.gms.wearable.WearableListenerService;&#10;&#10;import java.io.File;&#10;import java.io.FileOutputStream;&#10;import java.io.InputStream;&#10;&#10;public class RecordingListenerService extends WearableListenerService {&#10;&#10;    private static final String TAG = &quot;RecordingListenerService&quot;;&#10;    private static final String RECORDING_PATH = &quot;/recording_data&quot;;&#10;    private static final String MP4_PATH = &quot;/mp4_file&quot;;&#10;&#10;    @Override&#10;    public void onDataChanged(DataEventBuffer dataEvents) {&#10;        try {&#10;            for (DataEvent event : dataEvents) {&#10;                if (event.getType() == DataEvent.TYPE_CHANGED) {&#10;                    String path = event.getDataItem().getUri().getPath();&#10;                    Log.d(TAG, &quot;onDataChanged: path=&quot; + path);&#10;&#10;                    if (RECORDING_PATH.equals(path)) {&#10;                        DataMap dataMap = DataMapItem.fromDataItem(event.getDataItem()).getDataMap();&#10;                        final String title = dataMap.getString(&quot;title&quot;);&#10;                        final String fileName = dataMap.getString(&quot;fileName&quot;);&#10;                        final long timestamp = dataMap.getLong(&quot;timestamp&quot;);&#10;                        final Asset audioAsset = dataMap.getAsset(&quot;audio&quot;);&#10;&#10;                        if (audioAsset == null) {&#10;                            Log.e(TAG, &quot;No audio asset found in DataMap&quot;);&#10;                            continue;&#10;                        }&#10;&#10;                        // Latest API: getFdForAsset returns ParcelFileDescriptor&#10;                        Wearable.getDataClient(this).getFdForAsset(audioAsset)&#10;                                .addOnSuccessListener(parcelFileDescriptor -&gt; {&#10;                                    if (parcelFileDescriptor == null) {&#10;                                        Log.e(TAG, &quot;ParcelFileDescriptor is null&quot;);&#10;                                        return;&#10;                                    }&#10;&#10;                                    File dir = getExternalFilesDir(null);&#10;                                    File folder = new File(dir, &quot;EchoNoteAudio&quot;);&#10;                                    if (!folder.exists()) {&#10;                                        folder.mkdirs();&#10;                                    }&#10;                                    File outFile = new File(folder, fileName);&#10;&#10;                                    Log.d(TAG, &quot;Saving audio asset to: &quot; + outFile.getAbsolutePath());&#10;&#10;                                    try (&#10;                                            InputStream assetInputStream = parcelFileDescriptor.getInputStream();&#10;                                            FileOutputStream fos = new FileOutputStream(outFile)&#10;                                    ) {&#10;                                        byte[] buffer = new byte[8192];&#10;                                        int read;&#10;                                        while ((read = assetInputStream.read(buffer)) != -1) {&#10;                                            fos.write(buffer, 0, read);&#10;                                        }&#10;                                        fos.flush();&#10;&#10;                                        Log.d(TAG, &quot;Audio file saved: &quot; + outFile.getAbsolutePath());&#10;&#10;                                        // Do not try to get data from path, just save the file&#10;&#10;                                    } catch (Exception e) {&#10;                                        Log.e(TAG, &quot;Failed to write asset to file&quot;, e);&#10;                                    }&#10;                                })&#10;                                .addOnFailureListener(e -&gt;&#10;                                        Log.e(TAG, &quot;Failed to get asset ParcelFileDescriptor&quot;, e));&#10;                    } else if (MP4_PATH.equals(path)) {&#10;                        DataMap dataMap = DataMapItem.fromDataItem(event.getDataItem()).getDataMap();&#10;                        final String fileName = dataMap.getString(&quot;file_name&quot;);&#10;                        final long timestamp = dataMap.getLong(&quot;timestamp&quot;);&#10;                        final Asset mp4Asset = dataMap.getAsset(&quot;mp4_asset&quot;);&#10;&#10;                        if (mp4Asset == null) {&#10;                            Log.e(TAG, &quot;No mp4 asset found in DataMap&quot;);&#10;                            continue;&#10;                        }&#10;&#10;                        Wearable.getDataClient(this).getFdForAsset(mp4Asset)&#10;                                .addOnSuccessListener(parcelFileDescriptor -&gt; {&#10;                                    if (parcelFileDescriptor == null) {&#10;                                        Log.e(TAG, &quot;ParcelFileDescriptor is null&quot;);&#10;                                        return;&#10;                                    }&#10;                                    File dir = getExternalFilesDir(null);&#10;                                    File folder = new File(dir, &quot;EchoNoteAudio&quot;);&#10;                                    if (!folder.exists()) {&#10;                                        folder.mkdirs();&#10;                                    }&#10;                                    File outFile = new File(folder, fileName);&#10;                                    Log.d(TAG, &quot;Saving mp4 asset to: &quot; + outFile.getAbsolutePath());&#10;                                    try (&#10;                                            InputStream assetInputStream = parcelFileDescriptor.getInputStream();&#10;                                            FileOutputStream fos = new FileOutputStream(outFile)&#10;                                    ) {&#10;                                        byte[] buffer = new byte[8192];&#10;                                        int read;&#10;                                        while ((read = assetInputStream.read(buffer)) != -1) {&#10;                                            fos.write(buffer, 0, read);&#10;                                        }&#10;                                        fos.flush();&#10;                                        Log.d(TAG, &quot;MP4 file saved: &quot; + outFile.getAbsolutePath());&#10;                                        // Save RecordModel for this mp4 file so it appears in the list, use fileName as title&#10;                                        RecordModel recordModel = new RecordModel(fileName, outFile.getAbsolutePath(), timestamp);&#10;                                        RecordStorageHelper.saveRecord(RecordingListenerService.this, recordModel);&#10;                                    } catch (Exception e) {&#10;                                        Log.e(TAG, &quot;Failed to write mp4 asset to file&quot;, e);&#10;                                    }&#10;                                })&#10;                                .addOnFailureListener(e -&gt;&#10;                                        Log.e(TAG, &quot;Failed to get mp4 asset ParcelFileDescriptor&quot;, e));&#10;                    }&#10;                } else if (event.getType() == DataEvent.TYPE_DELETED) {&#10;                    Log.d(TAG, &quot;DataItem deleted: &quot; + event.getDataItem().getUri());&#10;                }&#10;            }&#10;        } catch (Exception e) {&#10;            Log.e(TAG, &quot;onDataChanged failed&quot;, e);&#10;        } finally {&#10;            dataEvents.release();&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/mobile/src/main/java/com/example/echonote/VideoPlayerActivity.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/mobile/src/main/java/com/example/echonote/VideoPlayerActivity.java" />
              <option name="originalContent" value="package com.example.echonote;&#10;&#10;import android.app.Activity;&#10;import android.net.Uri;&#10;import android.os.Bundle;&#10;import android.widget.Toast;&#10;&#10;import androidx.media3.common.MediaItem;&#10;import androidx.media3.common.Player;&#10;import androidx.media3.exoplayer.ExoPlayer;&#10;import androidx.media3.ui.PlayerView;&#10;&#10;public class VideoPlayerActivity extends Activity {&#10;    private ExoPlayer player;&#10;    private PlayerView playerView;&#10;&#10;    @Override&#10;    protected void onCreate(Bundle savedInstanceState) {&#10;        super.onCreate(savedInstanceState);&#10;        playerView = new PlayerView(this);&#10;        setContentView(playerView);&#10;&#10;        String filePath = getIntent().getStringExtra(&quot;mp4_path&quot;);&#10;        if (filePath != null) {&#10;            java.io.File file = new java.io.File(filePath);&#10;            if (!file.exists()) {&#10;                Toast.makeText(this, &quot;File does not exist: &quot; + filePath, Toast.LENGTH_LONG).show();&#10;                android.util.Log.e(&quot;VideoPlayerActivity&quot;, &quot;File does not exist: &quot; + filePath);&#10;                finish();&#10;                return;&#10;            }&#10;            player = new ExoPlayer.Builder(this).build();&#10;            playerView.setPlayer(player);&#10;            MediaItem mediaItem = MediaItem.fromUri(Uri.parse(filePath));&#10;            player.setMediaItem(mediaItem);&#10;            player.prepare();&#10;            player.play();&#10;        } else {&#10;            Toast.makeText(this, &quot;No file path provided&quot;, Toast.LENGTH_SHORT).show();&#10;            android.util.Log.e(&quot;VideoPlayerActivity&quot;, &quot;No file path provided&quot;);&#10;            finish();&#10;        }&#10;    }&#10;&#10;    @Override&#10;    protected void onDestroy() {&#10;        if (player != null) {&#10;            player.release();&#10;        }&#10;        super.onDestroy();&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.echonote;&#10;&#10;import android.app.Activity;&#10;import android.net.Uri;&#10;import android.os.Bundle;&#10;import android.widget.Toast;&#10;&#10;import androidx.core.content.FileProvider;&#10;import androidx.media3.common.MediaItem;&#10;import androidx.media3.common.Player;&#10;import androidx.media3.exoplayer.ExoPlayer;&#10;import androidx.media3.ui.PlayerView;&#10;&#10;public class VideoPlayerActivity extends Activity {&#10;    private ExoPlayer player;&#10;    private PlayerView playerView;&#10;&#10;    @Override&#10;    protected void onCreate(Bundle savedInstanceState) {&#10;        super.onCreate(savedInstanceState);&#10;        playerView = new PlayerView(this);&#10;        setContentView(playerView);&#10;&#10;        String filePath = getIntent().getStringExtra(&quot;mp4_path&quot;);&#10;        if (filePath != null) {&#10;            java.io.File file = new java.io.File(filePath);&#10;            android.util.Log.d(&quot;VideoPlayerActivity&quot;, &quot;Trying to play file: &quot; + filePath + &quot;, exists: &quot; + file.exists() + &quot;, readable: &quot; + file.canRead());&#10;            if (!file.exists() || !file.canRead()) {&#10;                Toast.makeText(this, &quot;File does not exist or is not readable: &quot; + filePath, Toast.LENGTH_LONG).show();&#10;                android.util.Log.e(&quot;VideoPlayerActivity&quot;, &quot;File does not exist or is not readable: &quot; + filePath);&#10;                finish();&#10;                return;&#10;            }&#10;            player = new ExoPlayer.Builder(this).build();&#10;            playerView.setPlayer(player);&#10;            Uri contentUri = FileProvider.getUriForFile(this, getPackageName() + &quot;.fileprovider&quot;, file);&#10;            MediaItem mediaItem = MediaItem.fromUri(contentUri);&#10;            player.setMediaItem(mediaItem);&#10;            player.prepare();&#10;            player.play();&#10;            player.addListener(new Player.Listener() {&#10;                @Override&#10;                public void onPlayerError(PlaybackException error) {&#10;                    android.util.Log.e(&quot;VideoPlayerActivity&quot;, &quot;Playback error: &quot; + error.getMessage(), error);&#10;                    Toast.makeText(VideoPlayerActivity.this, &quot;Playback error: &quot; + error.getMessage(), Toast.LENGTH_LONG).show();&#10;                }&#10;            });&#10;        } else {&#10;            Toast.makeText(this, &quot;No file path provided&quot;, Toast.LENGTH_SHORT).show();&#10;            android.util.Log.e(&quot;VideoPlayerActivity&quot;, &quot;No file path provided&quot;);&#10;            finish();&#10;        }&#10;    }&#10;&#10;    @Override&#10;    protected void onDestroy() {&#10;        if (player != null) {&#10;            player.release();&#10;        }&#10;        super.onDestroy();&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/mobile/src/main/java/com/example/echonote/WearDataListenerService.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/mobile/src/main/java/com/example/echonote/WearDataListenerService.java" />
              <option name="originalContent" value="package com.example.echonote;&#10;&#10;import android.content.Intent;&#10;import android.util.Log;&#10;&#10;import androidx.localbroadcastmanager.content.LocalBroadcastManager;&#10;&#10;import com.google.android.gms.wearable.Asset;&#10;import com.google.android.gms.wearable.DataEvent;&#10;import com.google.android.gms.wearable.DataEventBuffer;&#10;import com.google.android.gms.wearable.DataItem;&#10;import com.google.android.gms.wearable.DataMapItem;&#10;import com.google.android.gms.wearable.Wearable;&#10;import com.google.android.gms.wearable.WearableListenerService;&#10;&#10;import java.io.File;&#10;import java.io.FileOutputStream;&#10;import java.io.InputStream;&#10;&#10;public class WearDataListenerService extends WearableListenerService {&#10;&#10;    private static final String TAG = &quot;WearDataListener&quot;;&#10;&#10;    @Override&#10;    public void onDataChanged(DataEventBuffer dataEvents) {&#10;        for (DataEvent event : dataEvents) {&#10;            if (event.getType() == DataEvent.TYPE_CHANGED) {&#10;                DataItem item = event.getDataItem();&#10;                if (&quot;/mp4_file&quot;.equals(item.getUri().getPath())) {&#10;                    DataMapItem dataMapItem = DataMapItem.fromDataItem(item);&#10;                    Asset audioAsset = dataMapItem.getDataMap().getAsset(&quot;mp4_asset&quot;);&#10;                    String fileName = dataMapItem.getDataMap().getString(&quot;file_name&quot;);&#10;&#10;                    // Change extension to .mp3 if needed&#10;                    if (fileName != null &amp;&amp; fileName.endsWith(&quot;.mp4&quot;)) {&#10;                        fileName = fileName.substring(0, fileName.length() - 4) + &quot;.mp3&quot;;&#10;                    }&#10;&#10;                    Log.d(TAG, &quot;Received file: &quot; + fileName);&#10;&#10;                    if (audioAsset != null) {&#10;                        saveAssetToFile(audioAsset, fileName);&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private void saveAssetToFile(Asset asset, String fileName) {&#10;        if (asset == null) {&#10;            Log.w(TAG, &quot;Asset is null&quot;);&#10;            return;&#10;        }&#10;&#10;        try {&#10;            InputStream inputStream = Wearable.getDataClient(this).getFdForAsset(asset)&#10;                    .getResult().getInputStream();&#10;&#10;            if (inputStream == null) {&#10;                Log.e(TAG, &quot;InputStream for asset is null&quot;);&#10;                return;&#10;            }&#10;&#10;            File dir = getExternalFilesDir(null);&#10;            File folder = new File(dir, &quot;EchoNoteAudio&quot;);&#10;            if (!folder.exists()) folder.mkdirs();&#10;&#10;            File outFile = new File(folder, fileName);&#10;            try (FileOutputStream fos = new FileOutputStream(outFile)) {&#10;                byte[] buffer = new byte[4096];&#10;                int read;&#10;                while ((read = inputStream.read(buffer)) != -1) {&#10;                    fos.write(buffer, 0, read);&#10;                }&#10;                fos.flush();&#10;                Log.d(TAG, &quot;File saved: &quot; + outFile.getAbsolutePath());&#10;            }&#10;&#10;            // Notify RecordingListActivity UI to refresh&#10;            Intent intent = new Intent(&quot;com.example.echonote.NEW_RECORDING_RECEIVED&quot;);&#10;            LocalBroadcastManager.getInstance(this).sendBroadcast(intent);&#10;&#10;        } catch (Exception e) {&#10;            Log.e(TAG, &quot;Failed to save asset to file&quot;, e);&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.echonote;&#10;&#10;import android.content.Intent;&#10;import android.util.Log;&#10;&#10;import androidx.localbroadcastmanager.content.LocalBroadcastManager;&#10;&#10;import com.google.android.gms.wearable.Asset;&#10;import com.google.android.gms.wearable.DataEvent;&#10;import com.google.android.gms.wearable.DataEventBuffer;&#10;import com.google.android.gms.wearable.DataItem;&#10;import com.google.android.gms.wearable.DataMapItem;&#10;import com.google.android.gms.wearable.Wearable;&#10;import com.google.android.gms.wearable.WearableListenerService;&#10;&#10;import java.io.File;&#10;import java.io.FileOutputStream;&#10;import java.io.InputStream;&#10;&#10;public class WearDataListenerService extends WearableListenerService {&#10;&#10;    private static final String TAG = &quot;WearDataListener&quot;;&#10;&#10;    @Override&#10;    public void onDataChanged(DataEventBuffer dataEvents) {&#10;        for (DataEvent event : dataEvents) {&#10;            if (event.getType() == DataEvent.TYPE_CHANGED) {&#10;                DataItem item = event.getDataItem();&#10;                if (&quot;/mp4_file&quot;.equals(item.getUri().getPath())) {&#10;                    DataMapItem dataMapItem = DataMapItem.fromDataItem(item);&#10;                    Asset audioAsset = dataMapItem.getDataMap().getAsset(&quot;mp4_asset&quot;);&#10;                    String fileName = dataMapItem.getDataMap().getString(&quot;file_name&quot;);&#10;&#10;                    // Always save as .mp3 regardless of original extension&#10;                    if (fileName != null) {&#10;                        int dotIndex = fileName.lastIndexOf('.');&#10;                        if (dotIndex != -1) {&#10;                            fileName = fileName.substring(0, dotIndex) + &quot;.mp3&quot;;&#10;                        } else {&#10;                            fileName = fileName + &quot;.mp3&quot;;&#10;                        }&#10;                    }&#10;&#10;                    Log.d(TAG, &quot;Received file: &quot; + fileName);&#10;&#10;                    if (audioAsset != null) {&#10;                        saveAssetToFile(audioAsset, fileName);&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private void saveAssetToFile(Asset asset, String fileName) {&#10;        if (asset == null) {&#10;            Log.w(TAG, &quot;Asset is null&quot;);&#10;            return;&#10;        }&#10;&#10;        try {&#10;            InputStream inputStream = Wearable.getDataClient(this).getFdForAsset(asset)&#10;                    .getResult().getInputStream();&#10;&#10;            if (inputStream == null) {&#10;                Log.e(TAG, &quot;InputStream for asset is null&quot;);&#10;                return;&#10;            }&#10;&#10;            File dir = getExternalFilesDir(null);&#10;            File folder = new File(dir, &quot;EchoNoteAudio&quot;);&#10;            if (!folder.exists()) folder.mkdirs();&#10;&#10;            File outFile = new File(folder, fileName);&#10;            try (FileOutputStream fos = new FileOutputStream(outFile)) {&#10;                byte[] buffer = new byte[4096];&#10;                int read;&#10;                while ((read = inputStream.read(buffer)) != -1) {&#10;                    fos.write(buffer, 0, read);&#10;                }&#10;                fos.flush();&#10;                Log.d(TAG, &quot;File saved: &quot; + outFile.getAbsolutePath());&#10;            }&#10;&#10;            // Notify RecordingListActivity UI to refresh&#10;            Intent intent = new Intent(&quot;com.example.echonote.NEW_RECORDING_RECEIVED&quot;);&#10;            LocalBroadcastManager.getInstance(this).sendBroadcast(intent);&#10;&#10;        } catch (Exception e) {&#10;            Log.e(TAG, &quot;Failed to save asset to file&quot;, e);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/mobile/src/main/java/com/example/mobile/ExportHelper.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/mobile/src/main/java/com/example/mobile/ExportHelper.java" />
              <option name="originalContent" value="package com.example.mobile;&#10;&#10;import android.content.Context;&#10;import android.os.Environment;&#10;import android.util.Log;&#10;import android.widget.Toast;&#10;&#10;import org.apache.poi.xwpf.usermodel.XWPFDocument;&#10;import org.apache.poi.xwpf.usermodel.XWPFParagraph;&#10;&#10;import java.io.File;&#10;import java.io.FileOutputStream;&#10;&#10;public class ExportHelper {&#10;&#10;    private static final String TAG = &quot;ExportHelper&quot;;&#10;&#10;    /**&#10;     * Export MOM summary to Word document.&#10;     *&#10;     * @param context Android context.&#10;     * @param title   Title of the MOM.&#10;     * @param content Content to export.&#10;     */&#10;    public static void exportToWord(Context context, String title, String content) {&#10;        XWPFDocument document = new XWPFDocument();&#10;&#10;        try {&#10;            XWPFParagraph paragraphTitle = document.createParagraph();&#10;            paragraphTitle.createRun().setText(title);&#10;            paragraphTitle.createRun().setBold(true);&#10;            paragraphTitle.createRun().addBreak();&#10;&#10;            XWPFParagraph paragraphContent = document.createParagraph();&#10;            paragraphContent.createRun().setText(content);&#10;&#10;            // File path in external storage&#10;            File dir = new File(Environment.getExternalStorageDirectory(), &quot;EchoNoteExports&quot;);&#10;            if (!dir.exists()) {&#10;                dir.mkdirs();&#10;            }&#10;&#10;            String fileName = title.replaceAll(&quot;\\W+&quot;, &quot;_&quot;) + &quot;.docx&quot;;&#10;            File file = new File(dir, fileName);&#10;&#10;            FileOutputStream out = new FileOutputStream(file);&#10;            document.write(out);&#10;            out.close();&#10;            document.close();&#10;&#10;            Toast.makeText(context, &quot;Exported to &quot; + file.getAbsolutePath(), Toast.LENGTH_LONG).show();&#10;&#10;        } catch (Exception e) {&#10;            Log.e(TAG, &quot;Error exporting to Word&quot;, e);&#10;            Toast.makeText(context, &quot;Export failed&quot;, Toast.LENGTH_SHORT).show();&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.echonote;&#10;&#10;import android.content.Context;&#10;import android.os.Environment;&#10;import android.util.Log;&#10;import android.widget.Toast;&#10;&#10;import org.apache.poi.xwpf.usermodel.XWPFDocument;&#10;import org.apache.poi.xwpf.usermodel.XWPFParagraph;&#10;&#10;import java.io.File;&#10;import java.io.FileOutputStream;&#10;&#10;public class ExportHelper {&#10;&#10;    private static final String TAG = &quot;ExportHelper&quot;;&#10;&#10;    /**&#10;     * Export MOM summary to Word document.&#10;     *&#10;     * @param context Android context.&#10;     * @param title   Title of the MOM.&#10;     * @param content Content to export.&#10;     */&#10;    public static void exportToWord(Context context, String title, String content) {&#10;        XWPFDocument document = new XWPFDocument();&#10;&#10;        try {&#10;            XWPFParagraph paragraphTitle = document.createParagraph();&#10;            paragraphTitle.createRun().setText(title);&#10;            paragraphTitle.createRun().setBold(true);&#10;            paragraphTitle.createRun().addBreak();&#10;&#10;            XWPFParagraph paragraphContent = document.createParagraph();&#10;            paragraphContent.createRun().setText(content);&#10;&#10;            // File path in external storage&#10;            File dir = new File(Environment.getExternalStorageDirectory(), &quot;EchoNoteExports&quot;);&#10;            if (!dir.exists()) {&#10;                dir.mkdirs();&#10;            }&#10;&#10;            String fileName = title.replaceAll(&quot;\\W+&quot;, &quot;_&quot;) + &quot;.docx&quot;;&#10;            File file = new File(dir, fileName);&#10;&#10;            FileOutputStream out = new FileOutputStream(file);&#10;            document.write(out);&#10;            out.close();&#10;            document.close();&#10;&#10;            Toast.makeText(context, &quot;Exported to &quot; + file.getAbsolutePath(), Toast.LENGTH_LONG).show();&#10;&#10;        } catch (Exception e) {&#10;            Log.e(TAG, &quot;Error exporting to Word&quot;, e);&#10;            Toast.makeText(context, &quot;Export failed&quot;, Toast.LENGTH_SHORT).show();&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/mobile/src/main/java/com/example/mobile/MOMEditorActivity.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/mobile/src/main/java/com/example/mobile/MOMEditorActivity.java" />
              <option name="originalContent" value="package com.example.mobile;&#10;&#10;import android.app.Activity;&#10;import android.os.Bundle;&#10;import android.view.View;&#10;import android.widget.Button;&#10;import android.widget.EditText;&#10;import android.widget.Toast;&#10;&#10;public class MOMEditorActivity extends Activity {&#10;&#10;    private EditText etTitle, etTags, etReminder;&#10;    private Button btnSave;&#10;&#10;    @Override&#10;    protected void onCreate(Bundle savedInstanceState) {&#10;        super.onCreate(savedInstanceState);&#10;        setContentView(R.layout.activity_mom_editor);&#10;&#10;        etTitle = (EditText) findViewById(R.id.et_title);&#10;        etTags = (EditText) findViewById(R.id.et_tags);&#10;        etReminder = (EditText) findViewById(R.id.et_reminder);&#10;&#10;        btnSave = (Button) findViewById(R.id.btn_save);&#10;&#10;        btnSave.setOnClickListener(new View.OnClickListener() {&#10;            @Override&#10;            public void onClick(View v) {&#10;                saveMOM();&#10;            }&#10;        });&#10;    }&#10;&#10;    private void saveMOM() {&#10;        String title = etTitle.getText().toString().trim();&#10;        String tags = etTags.getText().toString().trim();&#10;        String reminder = etReminder.getText().toString().trim();&#10;&#10;        if (title.isEmpty()) {&#10;            Toast.makeText(this, &quot;Title is required&quot;, Toast.LENGTH_SHORT).show();&#10;            return;&#10;        }&#10;&#10;        // TODO: Save MOM details locally or in DB&#10;&#10;        Toast.makeText(this, &quot;MOM saved (stub)&quot;, Toast.LENGTH_SHORT).show();&#10;        finish();&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.echonote;&#10;&#10;import android.app.Activity;&#10;import android.os.Bundle;&#10;import android.view.View;&#10;import android.widget.Button;&#10;import android.widget.EditText;&#10;import android.widget.Toast;&#10;&#10;public class MOMEditorActivity extends Activity {&#10;&#10;    private EditText etTitle, etTags, etReminder;&#10;    private Button btnSave;&#10;&#10;    @Override&#10;    protected void onCreate(Bundle savedInstanceState) {&#10;        super.onCreate(savedInstanceState);&#10;        setContentView(R.layout.activity_mom_editor);&#10;&#10;        etTitle = (EditText) findViewById(R.id.et_title);&#10;        etTags = (EditText) findViewById(R.id.et_tags);&#10;        etReminder = (EditText) findViewById(R.id.et_reminder);&#10;&#10;        btnSave = (Button) findViewById(R.id.btn_save);&#10;&#10;        btnSave.setOnClickListener(new View.OnClickListener() {&#10;            @Override&#10;            public void onClick(View v) {&#10;                saveMOM();&#10;            }&#10;        });&#10;    }&#10;&#10;    private void saveMOM() {&#10;        String title = etTitle.getText().toString().trim();&#10;        String tags = etTags.getText().toString().trim();&#10;        String reminder = etReminder.getText().toString().trim();&#10;&#10;        if (title.isEmpty()) {&#10;            Toast.makeText(this, &quot;Title is required&quot;, Toast.LENGTH_SHORT).show();&#10;            return;&#10;        }&#10;&#10;        // TODO: Save MOM details locally or in DB&#10;&#10;        Toast.makeText(this, &quot;MOM saved (stub)&quot;, Toast.LENGTH_SHORT).show();&#10;        finish();&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/mobile/src/main/java/com/example/mobile/MOMListActivity.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/mobile/src/main/java/com/example/mobile/MOMListActivity.java" />
              <option name="originalContent" value="package com.example.mobile;&#10;import com.example.shared.MOM;  // If in shared module&#10;import com.example.shared.RecordModel;&#10;&#10;import android.app.Activity;&#10;import android.content.Intent;&#10;import android.os.Bundle;&#10;import android.view.View;&#10;import android.widget.AdapterView;&#10;import android.widget.ListView;&#10;&#10;import java.util.ArrayList;&#10;&#10;public class MOMListActivity extends Activity {&#10;&#10;    private ListView listView;&#10;    private MOMAdapter adapter;&#10;    private ArrayList&lt;MOM&gt; momList;&#10;    private RecordingReceiver recordingReceiver;&#10;&#10;    @Override&#10;    protected void onCreate(Bundle savedInstanceState) {&#10;        super.onCreate(savedInstanceState);&#10;        setContentView(R.layout.activity_mom_list);&#10;&#10;        listView = (ListView) findViewById(R.id.mom_list_view);&#10;&#10;        momList = new ArrayList&lt;MOM&gt;();&#10;        // TODO: Load actual MOM list from local DB or synced data&#10;        // Example: Load from file or database&#10;        momList = loadMOMListFromStorage();&#10;        adapter = new MOMAdapter(this, momList);&#10;        listView.setAdapter(adapter);&#10;&#10;        listView.setOnItemClickListener(new AdapterView.OnItemClickListener() {&#10;            @Override&#10;            public void onItemClick(AdapterView&lt;?&gt; parent, View view, int position, long id) {&#10;                MOM mom = momList.get(position);&#10;                Intent intent = new Intent(MOMListActivity.this, MOMDetailActivity.class);&#10;                intent.putExtra(&quot;mom_title&quot;, mom.getTitle());&#10;                intent.putExtra(&quot;mom_date&quot;, mom.getDate());&#10;                intent.putExtra(&quot;mom_tag&quot;, mom.getTag());&#10;                intent.putExtra(&quot;mom_read&quot;, mom.isRead());&#10;                startActivity(intent);&#10;            }&#10;        });&#10;    }&#10;&#10;    @Override&#10;    protected void onResume() {&#10;        super.onResume();&#10;        if (recordingReceiver == null) {&#10;            recordingReceiver = new RecordingReceiver(this);&#10;        }&#10;        recordingReceiver.register();&#10;        // Reload the list in case new recordings arrived&#10;        momList.clear();&#10;        adapter.notifyDataSetChanged();&#10;    }&#10;&#10;    @Override&#10;    protected void onPause() {&#10;        super.onPause();&#10;        if (recordingReceiver != null) {&#10;            recordingReceiver.unregister();&#10;        }&#10;    }&#10;&#10;    private ArrayList&lt;MOM&gt; loadMOMListFromStorage() {&#10;        ArrayList&lt;MOM&gt; list = new ArrayList&lt;MOM&gt;();&#10;        java.io.File file = new java.io.File(getFilesDir(), &quot;mom_list.dat&quot;);&#10;        if (file.exists()) {&#10;            try {&#10;                java.io.FileInputStream fis = new java.io.FileInputStream(file);&#10;                java.io.ObjectInputStream ois = new java.io.ObjectInputStream(fis);&#10;                list = (ArrayList&lt;MOM&gt;) ois.readObject();&#10;                ois.close();&#10;                fis.close();&#10;            } catch (Exception e) {&#10;                e.printStackTrace();&#10;            }&#10;        }&#10;        return list;&#10;    }&#10;&#10;    private ArrayList&lt;RecordModel&gt; loadRecordModelsFromStorage() {&#10;        ArrayList&lt;RecordModel&gt; list = new ArrayList&lt;RecordModel&gt;();&#10;        java.io.File file = new java.io.File(getFilesDir(), &quot;records.dat&quot;);&#10;        if (file.exists()) {&#10;            try {&#10;                java.io.FileInputStream fis = new java.io.FileInputStream(file);&#10;                java.io.ObjectInputStream ois = new java.io.ObjectInputStream(fis);&#10;                list = (ArrayList&lt;RecordModel&gt;) ois.readObject();&#10;                ois.close();&#10;                fis.close();&#10;            } catch (Exception e) {&#10;                e.printStackTrace();&#10;            }&#10;        }&#10;        return list;&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.echonote;&#10;import com.example.shared.MOM;  // If in shared module&#10;import com.example.shared.RecordModel;&#10;&#10;import android.app.Activity;&#10;import android.content.Intent;&#10;import android.os.Bundle;&#10;import android.view.View;&#10;import android.widget.AdapterView;&#10;import android.widget.ListView;&#10;&#10;import java.util.ArrayList;&#10;&#10;public class MOMListActivity extends Activity {&#10;&#10;    private ListView listView;&#10;    private MOMAdapter adapter;&#10;    private ArrayList&lt;MOM&gt; momList;&#10;&#10;    @Override&#10;    protected void onCreate(Bundle savedInstanceState) {&#10;        super.onCreate(savedInstanceState);&#10;        setContentView(R.layout.activity_mom_list);&#10;&#10;        listView = (ListView) findViewById(R.id.mom_list_view);&#10;&#10;        momList = new ArrayList&lt;MOM&gt;();&#10;        // TODO: Load actual MOM list from local DB or synced data&#10;        // Example: Load from file or database&#10;        momList = loadMOMListFromStorage();&#10;        adapter = new MOMAdapter(this, momList);&#10;        listView.setAdapter(adapter);&#10;&#10;        listView.setOnItemClickListener(new AdapterView.OnItemClickListener() {&#10;            @Override&#10;            public void onItemClick(AdapterView&lt;?&gt; parent, View view, int position, long id) {&#10;                MOM mom = momList.get(position);&#10;                Intent intent = new Intent(MOMListActivity.this, MOMDetailActivity.class);&#10;                intent.putExtra(&quot;mom_title&quot;, mom.getTitle());&#10;                intent.putExtra(&quot;mom_date&quot;, mom.getDate());&#10;                intent.putExtra(&quot;mom_tag&quot;, mom.getTag());&#10;                intent.putExtra(&quot;mom_read&quot;, mom.isRead());&#10;                startActivity(intent);&#10;            }&#10;        });&#10;    }&#10;&#10;    @Override&#10;    protected void onResume() {&#10;        super.onResume();&#10;        // Reload the list in case new recordings arrived&#10;        momList.clear();&#10;        adapter.notifyDataSetChanged();&#10;    }&#10;&#10;    @Override&#10;    protected void onPause() {&#10;        super.onPause();&#10;        // No RecordingReceiver to unregister&#10;    }&#10;&#10;    private ArrayList&lt;MOM&gt; loadMOMListFromStorage() {&#10;        ArrayList&lt;MOM&gt; list = new ArrayList&lt;MOM&gt;();&#10;        java.io.File file = new java.io.File(getFilesDir(), &quot;mom_list.dat&quot;);&#10;        if (file.exists()) {&#10;            try {&#10;                java.io.FileInputStream fis = new java.io.FileInputStream(file);&#10;                java.io.ObjectInputStream ois = new java.io.ObjectInputStream(fis);&#10;                list = (ArrayList&lt;MOM&gt;) ois.readObject();&#10;                ois.close();&#10;                fis.close();&#10;            } catch (Exception e) {&#10;                e.printStackTrace();&#10;            }&#10;        }&#10;        return list;&#10;    }&#10;&#10;    private ArrayList&lt;RecordModel&gt; loadRecordModelsFromStorage() {&#10;        ArrayList&lt;RecordModel&gt; list = new ArrayList&lt;RecordModel&gt;();&#10;        java.io.File file = new java.io.File(getFilesDir(), &quot;records.dat&quot;);&#10;        if (file.exists()) {&#10;            try {&#10;                java.io.FileInputStream fis = new java.io.FileInputStream(file);&#10;                java.io.ObjectInputStream ois = new java.io.ObjectInputStream(fis);&#10;                list = (ArrayList&lt;RecordModel&gt;) ois.readObject();&#10;                ois.close();&#10;                fis.close();&#10;            } catch (Exception e) {&#10;                e.printStackTrace();&#10;            }&#10;        }&#10;        return list;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/mobile/src/main/java/com/example/mobile/MainActivity_mobile.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/mobile/src/main/java/com/example/mobile/MainActivity_mobile.java" />
              <option name="originalContent" value="package com.example.mobile;&#10;&#10;import android.Manifest;&#10;import android.app.Activity;&#10;import android.content.Intent;&#10;import android.content.pm.PackageManager;&#10;import android.os.Bundle;&#10;import android.view.View;&#10;import androidx.core.app.ActivityCompat;&#10;import androidx.core.content.ContextCompat;&#10;import com.example.echonote.databinding.ActivityMainMobileBinding;&#10;&#10;public class MainActivity_mobile extends Activity {&#10;&#10;    private static final int REQUEST_STORAGE_PERMISSION = 1001;&#10;&#10;    @Override&#10;    protected void onCreate(Bundle savedInstanceState) {&#10;        super.onCreate(savedInstanceState);&#10;        ActivityMainMobileBinding binding = ActivityMainMobileBinding.inflate(getLayoutInflater());&#10;        setContentView(binding.getRoot());&#10;&#10;        // Request storage permission if not granted&#10;        if (!hasStoragePermission()) {&#10;            ActivityCompat.requestPermissions(this, new String[]{&#10;                    Manifest.permission.READ_EXTERNAL_STORAGE,&#10;                    Manifest.permission.WRITE_EXTERNAL_STORAGE,&#10;                    Manifest.permission.READ_MEDIA_AUDIO,&#10;                    Manifest.permission.READ_MEDIA_IMAGES,&#10;                    Manifest.permission.READ_MEDIA_VIDEO&#10;            }, REQUEST_STORAGE_PERMISSION);&#10;        }&#10;&#10;        binding.btnMomList.setOnClickListener(new View.OnClickListener() {&#10;            @Override&#10;            public void onClick(View v) {&#10;                Intent intent = new Intent(MainActivity_mobile.this, MOMListActivity.class);&#10;                startActivity(intent);&#10;            }&#10;        });&#10;&#10;        binding.btnRecordingList.setOnClickListener(new View.OnClickListener() {&#10;            @Override&#10;            public void onClick(View v) {&#10;                Intent intent = new Intent(MainActivity_mobile.this, RecordingListActivity.class);&#10;                startActivity(intent);&#10;            }&#10;        });&#10;    }&#10;&#10;    private boolean hasStoragePermission() {&#10;        return ContextCompat.checkSelfPermission(this, Manifest.permission.READ_EXTERNAL_STORAGE) == PackageManager.PERMISSION_GRANTED&#10;                &amp;&amp; ContextCompat.checkSelfPermission(this, Manifest.permission.WRITE_EXTERNAL_STORAGE) == PackageManager.PERMISSION_GRANTED;&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.echonote;&#10;&#10;import android.Manifest;&#10;import android.app.Activity;&#10;import android.content.Intent;&#10;import android.content.pm.PackageManager;&#10;import android.os.Bundle;&#10;import android.view.View;&#10;import androidx.core.app.ActivityCompat;&#10;import androidx.core.content.ContextCompat;&#10;import com.example.echonote.databinding.ActivityMainMobileBinding;&#10;&#10;public class MainActivity_mobile extends Activity {&#10;&#10;    private static final int REQUEST_STORAGE_PERMISSION = 1001;&#10;&#10;    @Override&#10;    protected void onCreate(Bundle savedInstanceState) {&#10;        super.onCreate(savedInstanceState);&#10;        ActivityMainMobileBinding binding = ActivityMainMobileBinding.inflate(getLayoutInflater());&#10;        setContentView(binding.getRoot());&#10;&#10;        // Request storage permission if not granted&#10;        if (!hasStoragePermission()) {&#10;            ActivityCompat.requestPermissions(this, new String[]{&#10;                    Manifest.permission.READ_EXTERNAL_STORAGE,&#10;                    Manifest.permission.WRITE_EXTERNAL_STORAGE,&#10;                    Manifest.permission.READ_MEDIA_AUDIO,&#10;                    Manifest.permission.READ_MEDIA_IMAGES,&#10;                    Manifest.permission.READ_MEDIA_VIDEO&#10;            }, REQUEST_STORAGE_PERMISSION);&#10;        }&#10;&#10;        binding.btnMomList.setOnClickListener(new View.OnClickListener() {&#10;            @Override&#10;            public void onClick(View v) {&#10;                Intent intent = new Intent(MainActivity_mobile.this, MOMListActivity.class);&#10;                startActivity(intent);&#10;            }&#10;        });&#10;&#10;        binding.btnRecordingList.setOnClickListener(new View.OnClickListener() {&#10;            @Override&#10;            public void onClick(View v) {&#10;                Intent intent = new Intent(MainActivity_mobile.this, RecordingListActivity.class);&#10;                startActivity(intent);&#10;            }&#10;        });&#10;    }&#10;&#10;    private boolean hasStoragePermission() {&#10;        return ContextCompat.checkSelfPermission(this, Manifest.permission.READ_EXTERNAL_STORAGE) == PackageManager.PERMISSION_GRANTED&#10;                &amp;&amp; ContextCompat.checkSelfPermission(this, Manifest.permission.WRITE_EXTERNAL_STORAGE) == PackageManager.PERMISSION_GRANTED;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/mobile/src/main/java/com/example/mobile/RecordingListenerService.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/mobile/src/main/java/com/example/mobile/RecordingListenerService.java" />
              <option name="originalContent" value="package com.example.mobile;&#10;&#10;import android.util.Log;&#10;&#10;import com.example.shared.RecordModel;&#10;import com.example.shared.RecordStorageHelper;&#10;import com.google.android.gms.wearable.Asset;&#10;import com.google.android.gms.wearable.DataEvent;&#10;import com.google.android.gms.wearable.DataEventBuffer;&#10;import com.google.android.gms.wearable.DataMap;&#10;import com.google.android.gms.wearable.DataMapItem;&#10;import com.google.android.gms.wearable.Wearable;&#10;import com.google.android.gms.wearable.WearableListenerService;&#10;&#10;import java.io.File;&#10;import java.io.FileOutputStream;&#10;import java.io.InputStream;&#10;&#10;public class RecordingListenerService extends WearableListenerService {&#10;&#10;    private static final String TAG = &quot;RecordingListenerService&quot;;&#10;    private static final String RECORDING_PATH = &quot;/recording_data&quot;;&#10;&#10;    @Override&#10;    public void onDataChanged(DataEventBuffer dataEvents) {&#10;        try {&#10;            for (DataEvent event : dataEvents) {&#10;                if (event.getType() == DataEvent.TYPE_CHANGED) {&#10;                    String path = event.getDataItem().getUri().getPath();&#10;                    Log.d(TAG, &quot;onDataChanged: path=&quot; + path);&#10;&#10;                    if (RECORDING_PATH.equals(path)) {&#10;                        DataMap dataMap = DataMapItem.fromDataItem(event.getDataItem()).getDataMap();&#10;                        final String title = dataMap.getString(&quot;title&quot;);&#10;                        final String fileName = dataMap.getString(&quot;fileName&quot;);&#10;                        final long timestamp = dataMap.getLong(&quot;timestamp&quot;);&#10;                        final Asset audioAsset = dataMap.getAsset(&quot;audio&quot;);&#10;&#10;                        if (audioAsset == null) {&#10;                            Log.e(TAG, &quot;No audio asset found in DataMap&quot;);&#10;                            continue;&#10;                        }&#10;&#10;                        // Latest API: getFdForAsset returns ParcelFileDescriptor&#10;                        Wearable.getDataClient(this).getFdForAsset(audioAsset)&#10;                                .addOnSuccessListener(parcelFileDescriptor -&gt; {&#10;                                    if (parcelFileDescriptor == null) {&#10;                                        Log.e(TAG, &quot;ParcelFileDescriptor is null&quot;);&#10;                                        return;&#10;                                    }&#10;&#10;                                    File dir = getExternalFilesDir(null);&#10;                                    File folder = new File(dir, &quot;EchoNoteAudio&quot;);&#10;                                    if (!folder.exists()) {&#10;                                        folder.mkdirs();&#10;                                    }&#10;                                    File outFile = new File(folder, fileName);&#10;&#10;                                    Log.d(TAG, &quot;Saving audio asset to: &quot; + outFile.getAbsolutePath());&#10;&#10;                                    try (&#10;                                            InputStream assetInputStream = parcelFileDescriptor.getInputStream();&#10;                                            FileOutputStream fos = new FileOutputStream(outFile)&#10;                                    ) {&#10;                                        byte[] buffer = new byte[8192];&#10;                                        int read;&#10;                                        while ((read = assetInputStream.read(buffer)) != -1) {&#10;                                            fos.write(buffer, 0, read);&#10;                                        }&#10;                                        fos.flush();&#10;&#10;                                        Log.d(TAG, &quot;Audio file saved: &quot; + outFile.getAbsolutePath());&#10;&#10;                                        // Save metadata locally&#10;                                        RecordModel recordModel =&#10;                                                new RecordModel(title, outFile.getAbsolutePath(), timestamp);&#10;                                        RecordStorageHelper.saveRecord(RecordingListenerService.this, recordModel);&#10;                                        int count = RecordStorageHelper.loadRecords(RecordingListenerService.this).size();&#10;                                        Log.d(TAG, &quot;RecordModel saved. Total records: &quot; + count);&#10;                                        android.widget.Toast.makeText(getApplicationContext(), &quot;Saved record. Total: &quot; + count, android.widget.Toast.LENGTH_LONG).show();&#10;&#10;                                    } catch (Exception e) {&#10;                                        Log.e(TAG, &quot;Failed to write asset to file&quot;, e);&#10;                                    }&#10;                                })&#10;                                .addOnFailureListener(e -&gt;&#10;                                        Log.e(TAG, &quot;Failed to get asset ParcelFileDescriptor&quot;, e));&#10;                    }&#10;                } else if (event.getType() == DataEvent.TYPE_DELETED) {&#10;                    Log.d(TAG, &quot;DataItem deleted: &quot; + event.getDataItem().getUri());&#10;                }&#10;            }&#10;        } catch (Exception e) {&#10;            Log.e(TAG, &quot;onDataChanged failed&quot;, e);&#10;        } finally {&#10;            dataEvents.release();&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.echonote;&#10;&#10;import android.util.Log;&#10;&#10;import com.example.shared.RecordModel;&#10;import com.example.shared.RecordStorageHelper;&#10;import com.google.android.gms.wearable.Asset;&#10;import com.google.android.gms.wearable.DataEvent;&#10;import com.google.android.gms.wearable.DataEventBuffer;&#10;import com.google.android.gms.wearable.DataMap;&#10;import com.google.android.gms.wearable.DataMapItem;&#10;import com.google.android.gms.wearable.Wearable;&#10;import com.google.android.gms.wearable.WearableListenerService;&#10;&#10;import java.io.File;&#10;import java.io.FileOutputStream;&#10;import java.io.InputStream;&#10;&#10;public class RecordingListenerService extends WearableListenerService {&#10;&#10;    private static final String TAG = &quot;RecordingListenerService&quot;;&#10;    private static final String RECORDING_PATH = &quot;/recording_data&quot;;&#10;&#10;    @Override&#10;    public void onDataChanged(DataEventBuffer dataEvents) {&#10;        try {&#10;            for (DataEvent event : dataEvents) {&#10;                if (event.getType() == DataEvent.TYPE_CHANGED) {&#10;                    String path = event.getDataItem().getUri().getPath();&#10;                    Log.d(TAG, &quot;onDataChanged: path=&quot; + path);&#10;&#10;                    if (RECORDING_PATH.equals(path)) {&#10;                        DataMap dataMap = DataMapItem.fromDataItem(event.getDataItem()).getDataMap();&#10;                        final String title = dataMap.getString(&quot;title&quot;);&#10;                        final String fileName = dataMap.getString(&quot;fileName&quot;);&#10;                        final long timestamp = dataMap.getLong(&quot;timestamp&quot;);&#10;                        final Asset audioAsset = dataMap.getAsset(&quot;audio&quot;);&#10;&#10;                        if (audioAsset == null) {&#10;                            Log.e(TAG, &quot;No audio asset found in DataMap&quot;);&#10;                            continue;&#10;                        }&#10;&#10;                        // Latest API: getFdForAsset returns ParcelFileDescriptor&#10;                        Wearable.getDataClient(this).getFdForAsset(audioAsset)&#10;                                .addOnSuccessListener(parcelFileDescriptor -&gt; {&#10;                                    if (parcelFileDescriptor == null) {&#10;                                        Log.e(TAG, &quot;ParcelFileDescriptor is null&quot;);&#10;                                        return;&#10;                                    }&#10;&#10;                                    File dir = getExternalFilesDir(null);&#10;                                    File folder = new File(dir, &quot;EchoNoteAudio&quot;);&#10;                                    if (!folder.exists()) {&#10;                                        folder.mkdirs();&#10;                                    }&#10;                                    File outFile = new File(folder, fileName);&#10;&#10;                                    Log.d(TAG, &quot;Saving audio asset to: &quot; + outFile.getAbsolutePath());&#10;&#10;                                    try (&#10;                                            InputStream assetInputStream = parcelFileDescriptor.getInputStream();&#10;                                            FileOutputStream fos = new FileOutputStream(outFile)&#10;                                    ) {&#10;                                        byte[] buffer = new byte[8192];&#10;                                        int read;&#10;                                        while ((read = assetInputStream.read(buffer)) != -1) {&#10;                                            fos.write(buffer, 0, read);&#10;                                        }&#10;                                        fos.flush();&#10;&#10;                                        Log.d(TAG, &quot;Audio file saved: &quot; + outFile.getAbsolutePath());&#10;&#10;                                        // Save metadata locally&#10;                                        RecordModel recordModel =&#10;                                                new RecordModel(title, outFile.getAbsolutePath(), timestamp);&#10;                                        RecordStorageHelper.saveRecord(RecordingListenerService.this, recordModel);&#10;                                        int count = RecordStorageHelper.loadRecords(RecordingListenerService.this).size();&#10;                                        Log.d(TAG, &quot;RecordModel saved. Total records: &quot; + count);&#10;                                        android.widget.Toast.makeText(getApplicationContext(), &quot;Saved record. Total: &quot; + count, android.widget.Toast.LENGTH_LONG).show();&#10;&#10;                                    } catch (Exception e) {&#10;                                        Log.e(TAG, &quot;Failed to write asset to file&quot;, e);&#10;                                    }&#10;                                })&#10;                                .addOnFailureListener(e -&gt;&#10;                                        Log.e(TAG, &quot;Failed to get asset ParcelFileDescriptor&quot;, e));&#10;                    }&#10;                } else if (event.getType() == DataEvent.TYPE_DELETED) {&#10;                    Log.d(TAG, &quot;DataItem deleted: &quot; + event.getDataItem().getUri());&#10;                }&#10;            }&#10;        } catch (Exception e) {&#10;            Log.e(TAG, &quot;onDataChanged failed&quot;, e);&#10;        } finally {&#10;            dataEvents.release();&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/mobile/src/main/java/com/example/mobile/RecordingReceiver.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/mobile/src/main/java/com/example/mobile/RecordingReceiver.java" />
              <option name="originalContent" value="package com.example.mobile;&#10;&#10;import android.content.Context;&#10;import android.util.Log;&#10;import android.widget.Toast;&#10;&#10;import androidx.annotation.NonNull;&#10;&#10;import com.example.shared.RecordModel;&#10;import com.example.shared.RecordStorageHelper;&#10;import com.google.android.gms.wearable.MessageClient;&#10;import com.google.android.gms.wearable.MessageEvent;&#10;import com.google.android.gms.wearable.Wearable;&#10;&#10;import java.io.ByteArrayInputStream;&#10;import java.io.ByteArrayOutputStream;&#10;import java.io.FileOutputStream;&#10;import java.io.ObjectInputStream;&#10;import java.util.concurrent.ExecutorService;&#10;import java.util.concurrent.Executors;&#10;&#10;public class RecordingReceiver implements MessageClient.OnMessageReceivedListener {&#10;&#10;    private static final String TAG = &quot;RecordingReceiver&quot;;&#10;&#10;    private Context context;&#10;&#10;    private RecordModel tempRecord;&#10;    private byte[] audioBytes;&#10;&#10;    private ExecutorService executor = Executors.newSingleThreadExecutor();&#10;&#10;    public RecordingReceiver(Context context) {&#10;        this.context = context.getApplicationContext();&#10;    }&#10;&#10;    public void register() {&#10;        Wearable.getMessageClient(context).addListener(this);&#10;    }&#10;&#10;    public void unregister() {&#10;        Wearable.getMessageClient(context).removeListener(this);&#10;    }&#10;&#10;    @Override&#10;    public void onMessageReceived(@NonNull MessageEvent messageEvent) {&#10;        if (messageEvent.getPath().equals(&quot;/recording&quot;)) {&#10;            // Metadata received&#10;            byte[] data = messageEvent.getData();&#10;&#10;            executor.execute(() -&gt; {&#10;                try {&#10;                    ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(data));&#10;                    tempRecord = (RecordModel) ois.readObject();&#10;                    ois.close();&#10;&#10;                    Log.d(TAG, &quot;Received RecordModel metadata: &quot; + tempRecord.getTitle());&#10;&#10;                } catch (Exception e) {&#10;                    Log.e(TAG, &quot;Failed to deserialize RecordModel&quot;, e);&#10;                }&#10;            });&#10;&#10;        } else if (messageEvent.getPath().equals(&quot;/recording_file&quot;)) {&#10;            // Audio bytes received&#10;            audioBytes = messageEvent.getData();&#10;&#10;            executor.execute(() -&gt; {&#10;                if (tempRecord == null) {&#10;                    Log.e(TAG, &quot;Audio received but metadata is null&quot;);&#10;                    return;&#10;                }&#10;                try {&#10;                    // Save audio file bytes to internal storage&#10;                    String fileName = tempRecord.getFilePath();&#10;                    FileOutputStream fos = context.openFileOutput(fileName.substring(fileName.lastIndexOf('/') + 1), Context.MODE_PRIVATE);&#10;                    fos.write(audioBytes);&#10;                    fos.close();&#10;&#10;                    // Update file path to local path (only file name because saved internally)&#10;                    tempRecord.setFilePath(context.getFilesDir() + &quot;/&quot; + fileName.substring(fileName.lastIndexOf('/') + 1));&#10;&#10;                    // Save the record metadata to local storage&#10;                    RecordStorageHelper.saveRecord(context, tempRecord);&#10;&#10;                    Log.d(TAG, &quot;Recording saved: &quot; + tempRecord.getTitle());&#10;&#10;                    // Notify user on UI thread&#10;                    android.os.Handler mainHandler = new android.os.Handler(context.getMainLooper());&#10;                    mainHandler.post(() -&gt; Toast.makeText(context, &quot;Recording received: &quot; + tempRecord.getTitle(), Toast.LENGTH_SHORT).show());&#10;&#10;                    tempRecord = null;&#10;                    audioBytes = null;&#10;&#10;                } catch (Exception e) {&#10;                    Log.e(TAG, &quot;Failed to save audio file&quot;, e);&#10;                }&#10;            });&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.mobile;&#10;&#10;import android.content.Context;&#10;import android.util.Log;&#10;import android.widget.Toast;&#10;&#10;import androidx.annotation.NonNull;&#10;&#10;import com.example.shared.RecordModel;&#10;import com.example.shared.RecordStorageHelper;&#10;import com.google.android.gms.wearable.MessageClient;&#10;import com.google.android.gms.wearable.MessageEvent;&#10;import com.google.android.gms.wearable.Wearable;&#10;&#10;import java.io.ByteArrayInputStream;&#10;import java.io.ByteArrayOutputStream;&#10;import java.io.FileOutputStream;&#10;import java.io.ObjectInputStream;&#10;import java.util.concurrent.ExecutorService;&#10;import java.util.concurrent.Executors;&#10;&#10;public class RecordingReceiver implements MessageClient.OnMessageReceivedListener {&#10;&#10;    private static final String TAG = &quot;RecordingReceiver&quot;;&#10;&#10;    private Context context;&#10;&#10;    private RecordModel tempRecord;&#10;    private byte[] audioBytes;&#10;&#10;    private ExecutorService executor = Executors.newSingleThreadExecutor();&#10;&#10;    public RecordingReceiver(Context context) {&#10;        this.context = context.getApplicationContext();&#10;    }&#10;&#10;    public void register() {&#10;        Wearable.getMessageClient(context).addListener(this);&#10;    }&#10;&#10;    public void unregister() {&#10;        Wearable.getMessageClient(context).removeListener(this);&#10;    }&#10;&#10;    @Override&#10;    public void onMessageReceived(@NonNull MessageEvent messageEvent) {&#10;        if (messageEvent.getPath().equals(&quot;/recording&quot;)) {&#10;            // Metadata received&#10;            byte[] data = messageEvent.getData();&#10;&#10;            executor.execute(() -&gt; {&#10;                try {&#10;                    ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(data));&#10;                    tempRecord = (RecordModel) ois.readObject();&#10;                    ois.close();&#10;&#10;                    Log.d(TAG, &quot;Received RecordModel metadata: &quot; + tempRecord.getTitle());&#10;                    Toast.makeText(context, &quot;Received RecordModel: &quot; + tempRecord.getTitle(), Toast.LENGTH_LONG).show();&#10;&#10;                } catch (Exception e) {&#10;                    Log.e(TAG, &quot;Failed to deserialize RecordModel&quot;, e);&#10;                }&#10;            });&#10;&#10;        } else if (messageEvent.getPath().equals(&quot;/recording_file&quot;)) {&#10;            // Audio bytes received&#10;            audioBytes = messageEvent.getData();&#10;&#10;            executor.execute(() -&gt; {&#10;                if (tempRecord == null) {&#10;                    Log.e(TAG, &quot;Audio received but metadata is null&quot;);&#10;                    return;&#10;                }&#10;                try {&#10;                    // Save audio file bytes to internal storage&#10;                    String fileName = tempRecord.getFilePath();&#10;                    FileOutputStream fos = context.openFileOutput(fileName.substring(fileName.lastIndexOf('/') + 1), Context.MODE_PRIVATE);&#10;                    fos.write(audioBytes);&#10;                    fos.close();&#10;&#10;                    // Update file path to local path (only file name because saved internally)&#10;                    tempRecord.setFilePath(context.getFilesDir() + &quot;/&quot; + fileName.substring(fileName.lastIndexOf('/') + 1));&#10;&#10;                    // Save the record metadata to local storage&#10;                    RecordStorageHelper.saveRecord(context, tempRecord);&#10;&#10;                    Log.d(TAG, &quot;Recording saved: &quot; + tempRecord.getTitle());&#10;                    Toast.makeText(context, &quot;Saved audio file: &quot; + fileName, Toast.LENGTH_LONG).show();&#10;&#10;                    tempRecord = null;&#10;                    audioBytes = null;&#10;&#10;                } catch (Exception e) {&#10;                    Log.e(TAG, &quot;Failed to save audio file&quot;, e);&#10;                }&#10;            });&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/mobile/src/main/res/xml/file_paths.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/mobile/src/main/res/xml/file_paths.xml" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;paths&gt;&#10;    &lt;external-files-path name=&quot;external_files&quot; path=&quot;.&quot; /&gt;&#10;    &lt;files-path name=&quot;files&quot; path=&quot;.&quot; /&gt;&#10;&lt;/paths&gt;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>